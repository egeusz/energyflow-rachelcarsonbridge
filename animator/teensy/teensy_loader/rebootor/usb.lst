   1               		.file	"usb.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.usb_wait_in_ready,"ax",@progbits
  12               	usb_wait_in_ready:
  13               	.LFB9:
  14               		.file 1 "usb.c"
   1:usb.c         **** /* Teensy Rebootor
   2:usb.c         ****  * http://www.pjrc.com/teensy/
   3:usb.c         ****  * Copyright (c) 2010 PJRC.COM, LLC
   4:usb.c         ****  * 
   5:usb.c         ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   6:usb.c         ****  * of this software and associated documentation files (the "Software"), to deal
   7:usb.c         ****  * in the Software without restriction, including without limitation the rights
   8:usb.c         ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   9:usb.c         ****  * copies of the Software, and to permit persons to whom the Software is
  10:usb.c         ****  * furnished to do so, subject to the following conditions:
  11:usb.c         ****  * 
  12:usb.c         ****  * The above description, website URL and copyright notice and this permission
  13:usb.c         ****  * notice shall be included in all copies or substantial portions of the Software.
  14:usb.c         ****  * 
  15:usb.c         ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:usb.c         ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  17:usb.c         ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  18:usb.c         ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  19:usb.c         ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  20:usb.c         ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  21:usb.c         ****  * THE SOFTWARE.
  22:usb.c         ****  */
  23:usb.c         **** 
  24:usb.c         **** // Version 1.0: Initial Release
  25:usb.c         **** 
  26:usb.c         **** #define USB_PRIVATE_INCLUDE
  27:usb.c         **** #include "usb.h"
  28:usb.c         **** #include <util/delay.h>
  29:usb.c         **** 
  30:usb.c         **** /**************************************************************************
  31:usb.c         ****  *
  32:usb.c         ****  *  Configurable Options
  33:usb.c         ****  *
  34:usb.c         ****  **************************************************************************/
  35:usb.c         **** 
  36:usb.c         **** #define STR_MANUFACTURER	L"PJRC"
  37:usb.c         **** #define STR_PRODUCT		L"Rebootor"
  38:usb.c         **** #define VENDOR_ID		0x16C0
  39:usb.c         **** #define PRODUCT_ID		0x0477
  40:usb.c         **** #define RX_SIZE			6	// receive packet size
  41:usb.c         **** 
  42:usb.c         **** 
  43:usb.c         **** /**************************************************************************
  44:usb.c         ****  *
  45:usb.c         ****  *  Endpoint Buffer Configuration
  46:usb.c         ****  *
  47:usb.c         ****  **************************************************************************/
  48:usb.c         **** 
  49:usb.c         **** #define ENDPOINT0_SIZE		32
  50:usb.c         **** 
  51:usb.c         **** 
  52:usb.c         **** static const uint8_t PROGMEM endpoint_config_table[] = {
  53:usb.c         **** 	1, EP_TYPE_INTERRUPT_IN,  EP_SIZE(8) | EP_SINGLE_BUFFER,
  54:usb.c         **** 	0,
  55:usb.c         **** 	0,
  56:usb.c         **** 	0
  57:usb.c         **** };
  58:usb.c         **** 
  59:usb.c         **** 
  60:usb.c         **** /**************************************************************************
  61:usb.c         ****  *
  62:usb.c         ****  *  Descriptor Data
  63:usb.c         ****  *
  64:usb.c         ****  **************************************************************************/
  65:usb.c         **** 
  66:usb.c         **** // Descriptors are the data that your computer reads when it auto-detects
  67:usb.c         **** // this USB device (called "enumeration" in USB lingo).  The most commonly
  68:usb.c         **** // changed items are editable at the top of this file.  Changing things
  69:usb.c         **** // in here should only be done by those who've read chapter 9 of the USB
  70:usb.c         **** // spec and relevant portions of any USB class specifications!
  71:usb.c         **** 
  72:usb.c         **** 
  73:usb.c         **** static const uint8_t PROGMEM device_descriptor[] = {
  74:usb.c         **** 	18,					// bLength
  75:usb.c         **** 	1,					// bDescriptorType
  76:usb.c         **** 	0x00, 0x02,				// bcdUSB
  77:usb.c         **** 	0,					// bDeviceClass
  78:usb.c         **** 	0,					// bDeviceSubClass
  79:usb.c         **** 	0,					// bDeviceProtocol
  80:usb.c         **** 	ENDPOINT0_SIZE,				// bMaxPacketSize0
  81:usb.c         **** 	LSB(VENDOR_ID), MSB(VENDOR_ID),		// idVendor
  82:usb.c         **** 	LSB(PRODUCT_ID), MSB(PRODUCT_ID),	// idProduct
  83:usb.c         **** 	0x00, 0x01,				// bcdDevice
  84:usb.c         **** 	1,					// iManufacturer
  85:usb.c         **** 	2,					// iProduct
  86:usb.c         **** 	0,					// iSerialNumber
  87:usb.c         **** 	1					// bNumConfigurations
  88:usb.c         **** };
  89:usb.c         **** 
  90:usb.c         **** static const uint8_t PROGMEM rawhid_hid_report_desc[] = {
  91:usb.c         **** 	0x06, 0x00, 0xFF,
  92:usb.c         **** 	0x0A, 0x00, 0x01,
  93:usb.c         **** 	0xA1, 0x01,				// Collection 0x01
  94:usb.c         **** 	0x75, 0x08,				// report size = 8 bits
  95:usb.c         **** 	0x15, 0x00,				// logical minimum = 0
  96:usb.c         **** 	0x26, 0xFF, 0x00,			// logical maximum = 255
  97:usb.c         **** 	0x95, RX_SIZE,				// report count
  98:usb.c         **** 	0x09, 0x02,				// usage
  99:usb.c         **** 	0x91, 0x02,				// Output (array)
 100:usb.c         **** 	0xC0					// end collection
 101:usb.c         **** };
 102:usb.c         **** 
 103:usb.c         **** 
 104:usb.c         **** #define CONFIG1_DESC_SIZE        (9+9+9+7)
 105:usb.c         **** #define RAWHID_HID_DESC_OFFSET   (9+9)
 106:usb.c         **** static const uint8_t PROGMEM config1_descriptor[CONFIG1_DESC_SIZE] = {
 107:usb.c         **** 	// configuration descriptor, USB spec 9.6.3, page 264-266, Table 9-10
 108:usb.c         **** 	9, 					// bLength;
 109:usb.c         **** 	2,					// bDescriptorType;
 110:usb.c         **** 	LSB(CONFIG1_DESC_SIZE),			// wTotalLength
 111:usb.c         **** 	MSB(CONFIG1_DESC_SIZE),
 112:usb.c         **** 	1,					// bNumInterfaces
 113:usb.c         **** 	1,					// bConfigurationValue
 114:usb.c         **** 	0,					// iConfiguration
 115:usb.c         **** 	0xC0,					// bmAttributes
 116:usb.c         **** 	50,					// bMaxPower
 117:usb.c         **** 
 118:usb.c         **** 	// interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
 119:usb.c         **** 	9,					// bLength
 120:usb.c         **** 	4,					// bDescriptorType
 121:usb.c         **** 	0,					// bInterfaceNumber
 122:usb.c         **** 	0,					// bAlternateSetting
 123:usb.c         **** 	1,					// bNumEndpoints
 124:usb.c         **** 	0x03,					// bInterfaceClass (0x03 = HID)
 125:usb.c         **** 	0x00,					// bInterfaceSubClass
 126:usb.c         **** 	0x00,					// bInterfaceProtocol
 127:usb.c         **** 	0,					// iInterface
 128:usb.c         **** 	// HID interface descriptor, HID 1.11 spec, section 6.2.1
 129:usb.c         **** 	9,					// bLength
 130:usb.c         **** 	0x21,					// bDescriptorType
 131:usb.c         **** 	0x11, 0x01,				// bcdHID
 132:usb.c         **** 	0,					// bCountryCode
 133:usb.c         **** 	1,					// bNumDescriptors
 134:usb.c         **** 	0x22,					// bDescriptorType
 135:usb.c         **** 	sizeof(rawhid_hid_report_desc),		// wDescriptorLength
 136:usb.c         **** 	0,
 137:usb.c         **** 	// endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
 138:usb.c         **** 	7,					// bLength
 139:usb.c         **** 	5,					// bDescriptorType
 140:usb.c         **** 	1 | 0x80,				// bEndpointAddress
 141:usb.c         **** 	0x03,					// bmAttributes (0x03=intr)
 142:usb.c         **** 	8, 0,					// wMaxPacketSize
 143:usb.c         **** 	0x80					// bInterval
 144:usb.c         **** };
 145:usb.c         **** 
 146:usb.c         **** // If you're desperate for a little extra code memory, these strings
 147:usb.c         **** // can be completely removed if iManufacturer, iProduct, iSerialNumber
 148:usb.c         **** // in the device desciptor are changed to zeros.
 149:usb.c         **** struct usb_string_descriptor_struct {
 150:usb.c         **** 	uint8_t bLength;
 151:usb.c         **** 	uint8_t bDescriptorType;
 152:usb.c         **** 	int16_t wString[];
 153:usb.c         **** };
 154:usb.c         **** static const struct usb_string_descriptor_struct PROGMEM string0 = {
 155:usb.c         **** 	4,
 156:usb.c         **** 	3,
 157:usb.c         **** 	{0x0409}
 158:usb.c         **** };
 159:usb.c         **** static const struct usb_string_descriptor_struct PROGMEM string1 = {
 160:usb.c         **** 	sizeof(STR_MANUFACTURER),
 161:usb.c         **** 	3,
 162:usb.c         **** 	STR_MANUFACTURER
 163:usb.c         **** };
 164:usb.c         **** static const struct usb_string_descriptor_struct PROGMEM string2 = {
 165:usb.c         **** 	sizeof(STR_PRODUCT),
 166:usb.c         **** 	3,
 167:usb.c         **** 	STR_PRODUCT
 168:usb.c         **** };
 169:usb.c         **** 
 170:usb.c         **** // This table defines which descriptor data is sent for each specific
 171:usb.c         **** // request from the host (in wValue and wIndex).
 172:usb.c         **** static const struct descriptor_list_struct {
 173:usb.c         **** 	uint16_t	wValue;
 174:usb.c         **** 	uint16_t	wIndex;
 175:usb.c         **** 	const uint8_t	*addr;
 176:usb.c         **** 	uint8_t		length;
 177:usb.c         **** } PROGMEM descriptor_list[] = {
 178:usb.c         **** 	{0x0100, 0x0000, device_descriptor, sizeof(device_descriptor)},
 179:usb.c         **** 	{0x0200, 0x0000, config1_descriptor, sizeof(config1_descriptor)},
 180:usb.c         **** 	{0x2200, 0, rawhid_hid_report_desc, sizeof(rawhid_hid_report_desc)},
 181:usb.c         **** 	{0x2100, 0, config1_descriptor+RAWHID_HID_DESC_OFFSET, 9},
 182:usb.c         **** 	{0x0300, 0x0000, (const uint8_t *)&string0, 4},
 183:usb.c         **** 	{0x0301, 0x0409, (const uint8_t *)&string1, sizeof(STR_MANUFACTURER)},
 184:usb.c         **** 	{0x0302, 0x0409, (const uint8_t *)&string2, sizeof(STR_PRODUCT)}
 185:usb.c         **** };
 186:usb.c         **** #define NUM_DESC_LIST (sizeof(descriptor_list)/sizeof(struct descriptor_list_struct))
 187:usb.c         **** 
 188:usb.c         **** 
 189:usb.c         **** /**************************************************************************
 190:usb.c         ****  *
 191:usb.c         ****  *  Variables - these are the only non-stack RAM usage
 192:usb.c         ****  *
 193:usb.c         ****  **************************************************************************/
 194:usb.c         **** 
 195:usb.c         **** // zero when we are not configured, non-zero when enumerated
 196:usb.c         **** static volatile uint8_t usb_configuration=0;
 197:usb.c         **** 
 198:usb.c         **** 
 199:usb.c         **** 
 200:usb.c         **** /**************************************************************************
 201:usb.c         ****  *
 202:usb.c         ****  *  Public Functions - these are the API intended for the user
 203:usb.c         ****  *
 204:usb.c         ****  **************************************************************************/
 205:usb.c         **** 
 206:usb.c         **** 
 207:usb.c         **** // initialize USB
 208:usb.c         **** void usb_init(void)
 209:usb.c         **** {
 210:usb.c         **** 	HW_CONFIG();
 211:usb.c         **** 	USB_FREEZE();				// enable USB
 212:usb.c         **** 	PLL_CONFIG();				// config PLL
 213:usb.c         ****         while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
 214:usb.c         ****         USB_CONFIG();				// start USB clock
 215:usb.c         ****         UDCON = 0;				// enable attach resistor
 216:usb.c         **** 	usb_configuration = 0;
 217:usb.c         ****         UDIEN = (1<<EORSTE);
 218:usb.c         **** 	sei();
 219:usb.c         **** }
 220:usb.c         **** 
 221:usb.c         **** 
 222:usb.c         **** 
 223:usb.c         **** /**************************************************************************
 224:usb.c         ****  *
 225:usb.c         ****  *  Private Functions - not intended for general user consumption....
 226:usb.c         ****  *
 227:usb.c         ****  **************************************************************************/
 228:usb.c         **** 
 229:usb.c         **** 
 230:usb.c         **** #if (GCC_VERSION >= 40300) && (GCC_VERSION < 40302)
 231:usb.c         **** #error "Buggy GCC 4.3.0 compiler, please upgrade!"
 232:usb.c         **** #endif
 233:usb.c         **** 
 234:usb.c         **** 
 235:usb.c         **** // USB Device Interrupt - handle all device-level events
 236:usb.c         **** // the transmit buffer flushing is triggered by the start of frame
 237:usb.c         **** //
 238:usb.c         **** ISR(USB_GEN_vect)
 239:usb.c         **** {
 240:usb.c         **** 	uint8_t intbits;
 241:usb.c         **** 
 242:usb.c         ****         intbits = UDINT;
 243:usb.c         ****         UDINT = 0;
 244:usb.c         ****         if (intbits & (1<<EORSTI)) {
 245:usb.c         **** 		UENUM = 0;
 246:usb.c         **** 		UECONX = 1;
 247:usb.c         **** 		UECFG0X = EP_TYPE_CONTROL;
 248:usb.c         **** 		UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 249:usb.c         **** 		UEIENX = (1<<RXSTPE);
 250:usb.c         **** 		usb_configuration = 0;
 251:usb.c         ****         }
 252:usb.c         **** }
 253:usb.c         **** 
 254:usb.c         **** 
 255:usb.c         **** 
 256:usb.c         **** // Misc functions to wait for ready and send/receive packets
 257:usb.c         **** static inline void usb_wait_in_ready(void)
 258:usb.c         **** {
  15               		.loc 1 258 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L3:
 259:usb.c         **** 	while (!(UEINTX & (1<<TXINI))) ;
  22               		.loc 1 259 0 discriminator 1
  23 0000 8091 E800 		lds r24,232
  24 0004 80FF      		sbrs r24,0
  25 0006 00C0      		rjmp .L3
  26               	/* epilogue start */
 260:usb.c         **** }
  27               		.loc 1 260 0
  28 0008 0895      		ret
  29               		.cfi_endproc
  30               	.LFE9:
  32               		.section	.text.usb_init,"ax",@progbits
  33               	.global	usb_init
  35               	usb_init:
  36               	.LFB7:
 209:usb.c         **** 	HW_CONFIG();
  37               		.loc 1 209 0
  38               		.cfi_startproc
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 0 */
  42               	.L__stack_usage = 0
 210:usb.c         **** 	USB_FREEZE();				// enable USB
  43               		.loc 1 210 0
  44 0000 81E0      		ldi r24,lo8(1)
  45 0002 8093 D700 		sts 215,r24
 211:usb.c         **** 	PLL_CONFIG();				// config PLL
  46               		.loc 1 211 0
  47 0006 80EA      		ldi r24,lo8(-96)
  48 0008 8093 D800 		sts 216,r24
 212:usb.c         ****         while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
  49               		.loc 1 212 0
  50 000c 82E1      		ldi r24,lo8(18)
  51 000e 89BD      		out 0x29,r24
  52               	.L7:
 213:usb.c         ****         USB_CONFIG();				// start USB clock
  53               		.loc 1 213 0 discriminator 1
  54 0010 09B4      		in __tmp_reg__,0x29
  55 0012 00FE      		sbrs __tmp_reg__,0
  56 0014 00C0      		rjmp .L7
 214:usb.c         ****         UDCON = 0;				// enable attach resistor
  57               		.loc 1 214 0
  58 0016 80E9      		ldi r24,lo8(-112)
  59 0018 8093 D800 		sts 216,r24
 215:usb.c         **** 	usb_configuration = 0;
  60               		.loc 1 215 0
  61 001c 1092 E000 		sts 224,__zero_reg__
 216:usb.c         ****         UDIEN = (1<<EORSTE);
  62               		.loc 1 216 0
  63 0020 1092 0000 		sts usb_configuration,__zero_reg__
 217:usb.c         **** 	sei();
  64               		.loc 1 217 0
  65 0024 88E0      		ldi r24,lo8(8)
  66 0026 8093 E200 		sts 226,r24
 218:usb.c         **** }
  67               		.loc 1 218 0
  68               	/* #APP */
  69               	 ;  218 "usb.c" 1
  70 002a 7894      		sei
  71               	 ;  0 "" 2
  72               	/* #NOAPP */
  73 002c 0895      		ret
  74               		.cfi_endproc
  75               	.LFE7:
  77               		.section	.text.__vector_10,"ax",@progbits
  78               	.global	__vector_10
  80               	__vector_10:
  81               	.LFB8:
 239:usb.c         **** 	uint8_t intbits;
  82               		.loc 1 239 0
  83               		.cfi_startproc
  84 0000 1F92      		push r1
  85               	.LCFI0:
  86               		.cfi_def_cfa_offset 3
  87               		.cfi_offset 1, -2
  88 0002 0F92      		push r0
  89               	.LCFI1:
  90               		.cfi_def_cfa_offset 4
  91               		.cfi_offset 0, -3
  92 0004 0FB6      		in r0,__SREG__
  93 0006 0F92      		push r0
  94 0008 1124      		clr __zero_reg__
  95 000a 8F93      		push r24
  96               	.LCFI2:
  97               		.cfi_def_cfa_offset 5
  98               		.cfi_offset 24, -4
  99               	/* prologue: Signal */
 100               	/* frame size = 0 */
 101               	/* stack size = 4 */
 102               	.L__stack_usage = 4
 242:usb.c         ****         UDINT = 0;
 103               		.loc 1 242 0
 104 000c 8091 E100 		lds r24,225
 105               	.LVL0:
 243:usb.c         ****         if (intbits & (1<<EORSTI)) {
 106               		.loc 1 243 0
 107 0010 1092 E100 		sts 225,__zero_reg__
 244:usb.c         **** 		UENUM = 0;
 108               		.loc 1 244 0
 109 0014 83FF      		sbrs r24,3
 110 0016 00C0      		rjmp .L8
 245:usb.c         **** 		UECONX = 1;
 111               		.loc 1 245 0
 112 0018 1092 E900 		sts 233,__zero_reg__
 246:usb.c         **** 		UECFG0X = EP_TYPE_CONTROL;
 113               		.loc 1 246 0
 114 001c 81E0      		ldi r24,lo8(1)
 115               	.LVL1:
 116 001e 8093 EB00 		sts 235,r24
 247:usb.c         **** 		UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 117               		.loc 1 247 0
 118 0022 1092 EC00 		sts 236,__zero_reg__
 248:usb.c         **** 		UEIENX = (1<<RXSTPE);
 119               		.loc 1 248 0
 120 0026 82E2      		ldi r24,lo8(34)
 121 0028 8093 ED00 		sts 237,r24
 249:usb.c         **** 		usb_configuration = 0;
 122               		.loc 1 249 0
 123 002c 88E0      		ldi r24,lo8(8)
 124 002e 8093 F000 		sts 240,r24
 250:usb.c         ****         }
 125               		.loc 1 250 0
 126 0032 1092 0000 		sts usb_configuration,__zero_reg__
 127               	.L8:
 128               	/* epilogue start */
 252:usb.c         **** 
 129               		.loc 1 252 0
 130 0036 8F91      		pop r24
 131 0038 0F90      		pop r0
 132 003a 0FBE      		out __SREG__,r0
 133 003c 0F90      		pop r0
 134 003e 1F90      		pop r1
 135 0040 1895      		reti
 136               		.cfi_endproc
 137               	.LFE8:
 139               		.section	.text.__vector_11,"ax",@progbits
 140               	.global	__vector_11
 142               	__vector_11:
 143               	.LFB13:
 261:usb.c         **** static inline void usb_send_in(void)
 262:usb.c         **** {
 263:usb.c         **** 	UEINTX = ~(1<<TXINI);
 264:usb.c         **** }
 265:usb.c         **** static inline void usb_wait_receive_out(void)
 266:usb.c         **** {
 267:usb.c         **** 	while (!(UEINTX & (1<<RXOUTI))) ;
 268:usb.c         **** }
 269:usb.c         **** static inline void usb_ack_out(void)
 270:usb.c         **** {
 271:usb.c         **** 	UEINTX = ~(1<<RXOUTI);
 272:usb.c         **** }
 273:usb.c         **** 
 274:usb.c         **** 
 275:usb.c         **** 
 276:usb.c         **** // USB Endpoint Interrupt - endpoint 0 is handled here.  The
 277:usb.c         **** // other endpoints are manipulated by the user-callable
 278:usb.c         **** // functions, and the start-of-frame interrupt.
 279:usb.c         **** //
 280:usb.c         **** ISR(USB_COM_vect)
 281:usb.c         **** {
 144               		.loc 1 281 0
 145               		.cfi_startproc
 146 0000 1F92      		push r1
 147               	.LCFI3:
 148               		.cfi_def_cfa_offset 3
 149               		.cfi_offset 1, -2
 150 0002 0F92      		push r0
 151               	.LCFI4:
 152               		.cfi_def_cfa_offset 4
 153               		.cfi_offset 0, -3
 154 0004 0FB6      		in r0,__SREG__
 155 0006 0F92      		push r0
 156 0008 1124      		clr __zero_reg__
 157 000a EF92      		push r14
 158               	.LCFI5:
 159               		.cfi_def_cfa_offset 5
 160               		.cfi_offset 14, -4
 161 000c FF92      		push r15
 162               	.LCFI6:
 163               		.cfi_def_cfa_offset 6
 164               		.cfi_offset 15, -5
 165 000e 0F93      		push r16
 166               	.LCFI7:
 167               		.cfi_def_cfa_offset 7
 168               		.cfi_offset 16, -6
 169 0010 1F93      		push r17
 170               	.LCFI8:
 171               		.cfi_def_cfa_offset 8
 172               		.cfi_offset 17, -7
 173 0012 2F93      		push r18
 174               	.LCFI9:
 175               		.cfi_def_cfa_offset 9
 176               		.cfi_offset 18, -8
 177 0014 3F93      		push r19
 178               	.LCFI10:
 179               		.cfi_def_cfa_offset 10
 180               		.cfi_offset 19, -9
 181 0016 4F93      		push r20
 182               	.LCFI11:
 183               		.cfi_def_cfa_offset 11
 184               		.cfi_offset 20, -10
 185 0018 5F93      		push r21
 186               	.LCFI12:
 187               		.cfi_def_cfa_offset 12
 188               		.cfi_offset 21, -11
 189 001a 6F93      		push r22
 190               	.LCFI13:
 191               		.cfi_def_cfa_offset 13
 192               		.cfi_offset 22, -12
 193 001c 7F93      		push r23
 194               	.LCFI14:
 195               		.cfi_def_cfa_offset 14
 196               		.cfi_offset 23, -13
 197 001e 8F93      		push r24
 198               	.LCFI15:
 199               		.cfi_def_cfa_offset 15
 200               		.cfi_offset 24, -14
 201 0020 9F93      		push r25
 202               	.LCFI16:
 203               		.cfi_def_cfa_offset 16
 204               		.cfi_offset 25, -15
 205 0022 AF93      		push r26
 206               	.LCFI17:
 207               		.cfi_def_cfa_offset 17
 208               		.cfi_offset 26, -16
 209 0024 BF93      		push r27
 210               	.LCFI18:
 211               		.cfi_def_cfa_offset 18
 212               		.cfi_offset 27, -17
 213 0026 EF93      		push r30
 214               	.LCFI19:
 215               		.cfi_def_cfa_offset 19
 216               		.cfi_offset 30, -18
 217 0028 FF93      		push r31
 218               	.LCFI20:
 219               		.cfi_def_cfa_offset 20
 220               		.cfi_offset 31, -19
 221 002a CF93      		push r28
 222               	.LCFI21:
 223               		.cfi_def_cfa_offset 21
 224               		.cfi_offset 28, -20
 225 002c DF93      		push r29
 226               	.LCFI22:
 227               		.cfi_def_cfa_offset 22
 228               		.cfi_offset 29, -21
 229 002e 1F92      		push __zero_reg__
 230               	.LCFI23:
 231               		.cfi_def_cfa_offset 23
 232 0030 CDB7      		in r28,__SP_L__
 233 0032 DEB7      		in r29,__SP_H__
 234               	.LCFI24:
 235               		.cfi_def_cfa_register 28
 236               	/* prologue: Signal */
 237               	/* frame size = 1 */
 238               	/* stack size = 22 */
 239               	.L__stack_usage = 22
 282:usb.c         ****         uint8_t intbits;
 283:usb.c         **** 	const uint8_t *list;
 284:usb.c         ****         const uint8_t *cfg;
 285:usb.c         **** 	uint8_t i, n, len, en;
 286:usb.c         **** 	uint8_t bmRequestType;
 287:usb.c         **** 	uint8_t bRequest;
 288:usb.c         **** 	uint16_t wValue;
 289:usb.c         **** 	uint16_t wIndex;
 290:usb.c         **** 	uint16_t wLength;
 291:usb.c         **** 	uint16_t desc_val;
 292:usb.c         **** 	const uint8_t *desc_addr;
 293:usb.c         **** 	uint8_t	desc_length;
 294:usb.c         **** 
 295:usb.c         ****         UENUM = 0;
 240               		.loc 1 295 0
 241 0034 1092 E900 		sts 233,__zero_reg__
 296:usb.c         **** 	intbits = UEINTX;
 242               		.loc 1 296 0
 243 0038 8091 E800 		lds r24,232
 244               	.LVL2:
 297:usb.c         ****         if (intbits & (1<<RXSTPI)) {
 245               		.loc 1 297 0
 246 003c 83FF      		sbrs r24,3
 247 003e 00C0      		rjmp .L14
 298:usb.c         ****                 bmRequestType = UEDATX;
 248               		.loc 1 298 0
 249 0040 9091 F100 		lds r25,241
 250               	.LVL3:
 299:usb.c         ****                 bRequest = UEDATX;
 251               		.loc 1 299 0
 252 0044 8091 F100 		lds r24,241
 253               	.LVL4:
 300:usb.c         ****                 wValue = UEDATX;
 254               		.loc 1 300 0
 255 0048 0091 F100 		lds r16,241
 256               	.LVL5:
 301:usb.c         ****                 wValue |= (UEDATX << 8);
 257               		.loc 1 301 0
 258 004c 2091 F100 		lds r18,241
 259 0050 10E0      		ldi r17,0
 260 0052 122B      		or r17,r18
 261               	.LVL6:
 302:usb.c         ****                 wIndex = UEDATX;
 262               		.loc 1 302 0
 263 0054 3091 F100 		lds r19,241
 264               	.LVL7:
 303:usb.c         ****                 wIndex |= (UEDATX << 8);
 265               		.loc 1 303 0
 266 0058 2091 F100 		lds r18,241
 267 005c E32E      		mov r14,r19
 268 005e F12C      		mov r15,__zero_reg__
 269 0060 F22A      		or r15,r18
 270               	.LVL8:
 304:usb.c         ****                 wLength = UEDATX;
 271               		.loc 1 304 0
 272 0062 2091 F100 		lds r18,241
 273               	.LVL9:
 305:usb.c         ****                 wLength |= (UEDATX << 8);
 274               		.loc 1 305 0
 275 0066 6091 F100 		lds r22,241
 276               	.LVL10:
 306:usb.c         ****                 UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
 277               		.loc 1 306 0
 278 006a 32EF      		ldi r19,lo8(-14)
 279 006c 3093 E800 		sts 232,r19
 307:usb.c         ****                 if (bRequest == GET_DESCRIPTOR) {
 280               		.loc 1 307 0
 281 0070 8630      		cpi r24,lo8(6)
 282 0072 01F0      		breq .+2
 283 0074 00C0      		rjmp .L57
 284 0076 37E0      		ldi r19,lo8(7)
 285 0078 80E0      		ldi r24,lo8(descriptor_list)
 286 007a 90E0      		ldi r25,hi8(descriptor_list)
 287               	.LVL11:
 288               	.L25:
 289               	.LBB58:
 308:usb.c         **** 			list = (const uint8_t *)descriptor_list;
 309:usb.c         **** 			for (i=0; ; i++) {
 310:usb.c         **** 				if (i >= NUM_DESC_LIST) {
 311:usb.c         **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
 312:usb.c         **** 					return;
 313:usb.c         **** 				}
 314:usb.c         **** 				desc_val = pgm_read_word(list);
 290               		.loc 1 314 0
 291 007c FC01      		movw r30,r24
 292               	/* #APP */
 293               	 ;  314 "usb.c" 1
 294 007e 4591      		lpm r20, Z+
 295 0080 5491      		lpm r21, Z
 296               		
 297               	 ;  0 "" 2
 298               	.LVL12:
 299               	/* #NOAPP */
 300               	.LBE58:
 315:usb.c         **** 				if (desc_val != wValue) {
 301               		.loc 1 315 0
 302 0082 4017      		cp r20,r16
 303 0084 5107      		cpc r21,r17
 304 0086 01F4      		brne .L58
 305               	.LVL13:
 316:usb.c         **** 					list += sizeof(struct descriptor_list_struct);
 317:usb.c         **** 					continue;
 318:usb.c         **** 				}
 319:usb.c         **** 				list += 2;
 306               		.loc 1 319 0
 307 0088 FC01      		movw r30,r24
 308 008a 3296      		adiw r30,2
 309               	.LVL14:
 310               	.LBB59:
 320:usb.c         **** 				desc_val = pgm_read_word(list);
 311               		.loc 1 320 0
 312               	/* #APP */
 313               	 ;  320 "usb.c" 1
 314 008c 4591      		lpm r20, Z+
 315 008e 5491      		lpm r21, Z
 316               		
 317               	 ;  0 "" 2
 318               	.LVL15:
 319               	/* #NOAPP */
 320               	.LBE59:
 321:usb.c         **** 				if (desc_val != wIndex) {
 321               		.loc 1 321 0
 322 0090 4E15      		cp r20,r14
 323 0092 5F05      		cpc r21,r15
 324 0094 01F0      		breq .L20
 325               	.LVL16:
 326               	.L58:
 322:usb.c         **** 					list += sizeof(struct descriptor_list_struct)-2;
 327               		.loc 1 322 0
 328 0096 0796      		adiw r24,7
 329               	.LVL17:
 330 0098 3150      		subi r19,lo8(-(-1))
 331               	.LVL18:
 310:usb.c         **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
 332               		.loc 1 310 0
 333 009a 01F4      		brne .L25
 334 009c 00C0      		rjmp .L14
 335               	.LVL19:
 336               	.L20:
 323:usb.c         **** 					continue;
 324:usb.c         **** 				}
 325:usb.c         **** 				list += 2;
 337               		.loc 1 325 0
 338 009e FC01      		movw r30,r24
 339 00a0 3496      		adiw r30,4
 340               	.LVL20:
 326:usb.c         **** 				desc_addr = (const uint8_t *)pgm_read_word(list);
 341               		.loc 1 326 0
 342               	/* #APP */
 343               	 ;  326 "usb.c" 1
 344 00a2 4591      		lpm r20, Z+
 345 00a4 5491      		lpm r21, Z
 346               		
 347               	 ;  0 "" 2
 348               	.LVL21:
 327:usb.c         **** 				list += 2;
 349               		.loc 1 327 0
 350               	/* #NOAPP */
 351 00a6 FC01      		movw r30,r24
 352 00a8 3696      		adiw r30,6
 353               	.LVL22:
 354               	.LBB60:
 328:usb.c         **** 				desc_length = pgm_read_byte(list);
 355               		.loc 1 328 0
 356               	/* #APP */
 357               	 ;  328 "usb.c" 1
 358 00aa 8491      		lpm r24, Z
 359               		
 360               	 ;  0 "" 2
 361               	.LVL23:
 362               	/* #NOAPP */
 363               	.LBE60:
 305:usb.c         ****                 UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
 364               		.loc 1 305 0
 365 00ac 30E0      		ldi r19,0
 366               	.LVL24:
 367 00ae 362B      		or r19,r22
 329:usb.c         **** 				break;
 330:usb.c         **** 			}
 331:usb.c         **** 			len = (wLength < 256) ? wLength : 255;
 368               		.loc 1 331 0
 369 00b0 2F3F      		cpi r18,-1
 370 00b2 3105      		cpc r19,__zero_reg__
 371 00b4 01F0      		breq .L21
 372 00b6 00F0      		brlo .L21
 373 00b8 2FEF      		ldi r18,lo8(-1)
 374 00ba 30E0      		ldi r19,0
 375               	.LVL25:
 376               	.L21:
 377 00bc 2817      		cp r18,r24
 378 00be 00F4      		brsh .L22
 379 00c0 822F      		mov r24,r18
 380               	.LVL26:
 381               	.L22:
 382               	.LBB61:
 383               	.LBB62:
 263:usb.c         **** }
 384               		.loc 1 263 0
 385 00c2 3EEF      		ldi r19,lo8(-2)
 386               	.LVL27:
 387               	.L27:
 388               	.LBE62:
 389               	.LBE61:
 332:usb.c         **** 			if (len > desc_length) len = desc_length;
 333:usb.c         **** 			do {
 334:usb.c         **** 				// wait for host ready for IN packet
 335:usb.c         **** 				do {
 336:usb.c         **** 					i = UEINTX;
 390               		.loc 1 336 0 discriminator 1
 391 00c4 9091 E800 		lds r25,232
 392               	.LVL28:
 337:usb.c         **** 				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 393               		.loc 1 337 0 discriminator 1
 394 00c8 292F      		mov r18,r25
 395 00ca 2570      		andi r18,lo8(5)
 396 00cc 01F0      		breq .L27
 338:usb.c         **** 				if (i & (1<<RXOUTI)) return;	// abort
 397               		.loc 1 338 0
 398 00ce 92FD      		sbrc r25,2
 399 00d0 00C0      		rjmp .L13
 339:usb.c         **** 				// send IN packet
 340:usb.c         **** 				n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 400               		.loc 1 340 0
 401 00d2 982F      		mov r25,r24
 402               	.LVL29:
 403 00d4 8132      		cpi r24,lo8(33)
 404 00d6 00F0      		brlo .L29
 405 00d8 90E2      		ldi r25,lo8(32)
 406               	.L29:
 407               	.LVL30:
 341:usb.c         **** 				for (i = n; i; i--) {
 408               		.loc 1 341 0
 409 00da FA01      		movw r30,r20
 410 00dc 292F      		mov r18,r25
 411               	.LVL31:
 412               	.L30:
 413               		.loc 1 341 0 is_stmt 0 discriminator 1
 414 00de 2223      		tst r18
 415 00e0 01F0      		breq .L61
 416               	.LVL32:
 417               	.LBB64:
 342:usb.c         **** 					UEDATX = pgm_read_byte(desc_addr++);
 418               		.loc 1 342 0 is_stmt 1 discriminator 2
 419               	/* #APP */
 420               	 ;  342 "usb.c" 1
 421 00e2 6491      		lpm r22, Z
 422               		
 423               	 ;  0 "" 2
 424               	.LVL33:
 425               	/* #NOAPP */
 426               	.LBE64:
 427 00e4 6093 F100 		sts 241,r22
 341:usb.c         **** 				for (i = n; i; i--) {
 428               		.loc 1 341 0 discriminator 2
 429 00e8 2150      		subi r18,lo8(-(-1))
 430               	.LVL34:
 431 00ea 3196      		adiw r30,1
 432               	.LVL35:
 433 00ec 00C0      		rjmp .L30
 434               	.LVL36:
 435               	.L61:
 436 00ee 490F      		add r20,r25
 437 00f0 511D      		adc r21,__zero_reg__
 343:usb.c         **** 				}
 344:usb.c         **** 				len -= n;
 438               		.loc 1 344 0
 439 00f2 891B      		sub r24,r25
 440               	.LVL37:
 441               	.LBB65:
 442               	.LBB63:
 263:usb.c         **** }
 443               		.loc 1 263 0
 444 00f4 3093 E800 		sts 232,r19
 445               	.LBE63:
 446               	.LBE65:
 345:usb.c         **** 				usb_send_in();
 346:usb.c         **** 			} while (len || n == ENDPOINT0_SIZE);
 447               		.loc 1 346 0
 448 00f8 8111      		cpse r24,__zero_reg__
 449 00fa 00C0      		rjmp .L27
 450               		.loc 1 346 0 is_stmt 0 discriminator 1
 451 00fc 9032      		cpi r25,lo8(32)
 452 00fe 01F0      		breq .L27
 453 0100 00C0      		rjmp .L13
 454               	.LVL38:
 455               	.L57:
 347:usb.c         **** 			return;
 348:usb.c         ****                 }
 349:usb.c         **** 		if (bRequest == SET_ADDRESS) {
 456               		.loc 1 349 0 is_stmt 1
 457 0102 8530      		cpi r24,lo8(5)
 458 0104 01F4      		brne .L34
 459               	.LBB66:
 460               	.LBB67:
 263:usb.c         **** }
 461               		.loc 1 263 0
 462 0106 8EEF      		ldi r24,lo8(-2)
 463               	.LVL39:
 464 0108 8093 E800 		sts 232,r24
 465               	.LBE67:
 466               	.LBE66:
 350:usb.c         **** 			usb_send_in();
 351:usb.c         **** 			usb_wait_in_ready();
 467               		.loc 1 351 0
 468 010c 0E94 0000 		call usb_wait_in_ready
 469               	.LVL40:
 352:usb.c         **** 			UDADDR = wValue | (1<<ADDEN);
 470               		.loc 1 352 0
 471 0110 0068      		ori r16,lo8(-128)
 472               	.LVL41:
 473 0112 0093 E300 		sts 227,r16
 353:usb.c         **** 			return;
 474               		.loc 1 353 0
 475 0116 00C0      		rjmp .L13
 476               	.LVL42:
 477               	.L34:
 354:usb.c         **** 		}
 355:usb.c         **** 		if (bRequest == SET_CONFIGURATION && bmRequestType == 0) {
 478               		.loc 1 355 0
 479 0118 8930      		cpi r24,lo8(9)
 480 011a 01F4      		brne .L35
 481               		.loc 1 355 0 is_stmt 0 discriminator 1
 482 011c 9111      		cpse r25,__zero_reg__
 483 011e 00C0      		rjmp .L36
 356:usb.c         **** 			usb_configuration = wValue;
 484               		.loc 1 356 0 is_stmt 1
 485 0120 0093 0000 		sts usb_configuration,r16
 486               	.LBB68:
 487               	.LBB69:
 263:usb.c         **** }
 488               		.loc 1 263 0
 489 0124 8EEF      		ldi r24,lo8(-2)
 490               	.LVL43:
 491 0126 8093 E800 		sts 232,r24
 492               	.LVL44:
 493               	.LBE69:
 494               	.LBE68:
 357:usb.c         **** 			usb_send_in();
 358:usb.c         **** 			cfg = endpoint_config_table;
 359:usb.c         **** 			for (i=1; i<5; i++) {
 495               		.loc 1 359 0
 496 012a 41E0      		ldi r20,lo8(1)
 358:usb.c         **** 			for (i=1; i<5; i++) {
 497               		.loc 1 358 0
 498 012c 80E0      		ldi r24,lo8(endpoint_config_table)
 499 012e 90E0      		ldi r25,hi8(endpoint_config_table)
 500               	.LVL45:
 501               	.L39:
 360:usb.c         **** 				UENUM = i;
 502               		.loc 1 360 0
 503 0130 4093 E900 		sts 233,r20
 504               	.LBB70:
 361:usb.c         **** 				en = pgm_read_byte(cfg++);
 505               		.loc 1 361 0
 506 0134 9C01      		movw r18,r24
 507 0136 2F5F      		subi r18,-1
 508 0138 3F4F      		sbci r19,-1
 509               	.LVL46:
 510 013a FC01      		movw r30,r24
 511               	/* #APP */
 512               	 ;  361 "usb.c" 1
 513 013c 5491      		lpm r21, Z
 514               		
 515               	 ;  0 "" 2
 516               	.LVL47:
 517               	/* #NOAPP */
 518               	.LBE70:
 362:usb.c         **** 				UECONX = en;
 519               		.loc 1 362 0
 520 013e 5093 EB00 		sts 235,r21
 363:usb.c         **** 				if (en) {
 521               		.loc 1 363 0
 522 0142 5523      		tst r21
 523 0144 01F0      		breq .L37
 524               	.LVL48:
 525               	.LBB71:
 364:usb.c         **** 					UECFG0X = pgm_read_byte(cfg++);
 526               		.loc 1 364 0
 527 0146 F901      		movw r30,r18
 528               	/* #APP */
 529               	 ;  364 "usb.c" 1
 530 0148 2491      		lpm r18, Z
 531               		
 532               	 ;  0 "" 2
 533               	.LVL49:
 534               	/* #NOAPP */
 535               	.LBE71:
 536 014a 2093 EC00 		sts 236,r18
 537               	.LBB72:
 365:usb.c         **** 					UECFG1X = pgm_read_byte(cfg++);
 538               		.loc 1 365 0
 539 014e 9C01      		movw r18,r24
 540               	.LVL50:
 541 0150 2D5F      		subi r18,-3
 542 0152 3F4F      		sbci r19,-1
 543               	.LVL51:
 544 0154 3196      		adiw r30,1
 545               	.LVL52:
 546               	/* #APP */
 547               	 ;  365 "usb.c" 1
 548 0156 8491      		lpm r24, Z
 549               		
 550               	 ;  0 "" 2
 551               	.LVL53:
 552               	/* #NOAPP */
 553               	.LBE72:
 554 0158 8093 ED00 		sts 237,r24
 555               	.LVL54:
 556               	.L37:
 359:usb.c         **** 				UENUM = i;
 557               		.loc 1 359 0
 558 015c 4F5F      		subi r20,lo8(-(1))
 559               	.LVL55:
 560 015e 4530      		cpi r20,lo8(5)
 561 0160 01F0      		breq .L38
 562 0162 C901      		movw r24,r18
 563 0164 00C0      		rjmp .L39
 564               	.L38:
 366:usb.c         **** 				}
 367:usb.c         **** 			}
 368:usb.c         ****         		UERST = 0x1E;
 565               		.loc 1 368 0
 566 0166 8EE1      		ldi r24,lo8(30)
 567 0168 00C0      		rjmp .L59
 568               	.LVL56:
 569               	.L35:
 369:usb.c         ****         		UERST = 0;
 370:usb.c         **** 			return;
 371:usb.c         **** 		}
 372:usb.c         **** 		if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) {
 570               		.loc 1 372 0
 571 016a 8830      		cpi r24,lo8(8)
 572 016c 01F4      		brne .L40
 573               		.loc 1 372 0 is_stmt 0 discriminator 1
 574 016e 9038      		cpi r25,lo8(-128)
 575 0170 01F0      		breq .+2
 576 0172 00C0      		rjmp .L41
 373:usb.c         **** 			usb_wait_in_ready();
 577               		.loc 1 373 0 is_stmt 1
 578 0174 0E94 0000 		call usb_wait_in_ready
 579               	.LVL57:
 374:usb.c         **** 			UEDATX = usb_configuration;
 580               		.loc 1 374 0
 581 0178 8091 0000 		lds r24,usb_configuration
 582 017c 8093 F100 		sts 241,r24
 583 0180 00C0      		rjmp .L60
 584               	.LVL58:
 585               	.L40:
 375:usb.c         **** 			usb_send_in();
 376:usb.c         **** 			return;
 377:usb.c         **** 		}
 378:usb.c         **** 
 379:usb.c         **** 		if (bRequest == GET_STATUS) {
 586               		.loc 1 379 0
 587 0182 8111      		cpse r24,__zero_reg__
 588 0184 00C0      		rjmp .L36
 380:usb.c         **** 			usb_wait_in_ready();
 589               		.loc 1 380 0
 590 0186 9983      		std Y+1,r25
 591 0188 0E94 0000 		call usb_wait_in_ready
 592               	.LVL59:
 381:usb.c         **** 			i = 0;
 382:usb.c         **** 			if (bmRequestType == 0x82) {
 593               		.loc 1 382 0
 594 018c 9981      		ldd r25,Y+1
 595 018e 9238      		cpi r25,lo8(-126)
 596 0190 01F4      		brne .L47
 383:usb.c         **** 				UENUM = wIndex;
 597               		.loc 1 383 0
 598 0192 E092 E900 		sts 233,r14
 384:usb.c         **** 				if (UECONX & (1<<STALLRQ)) i = 1;
 599               		.loc 1 384 0
 600 0196 8091 EB00 		lds r24,235
 601 019a 85FB      		bst r24,5
 602 019c 8827      		clr r24
 603 019e 80F9      		bld r24,0
 604               	.LVL60:
 385:usb.c         **** 				UENUM = 0;
 605               		.loc 1 385 0
 606 01a0 1092 E900 		sts 233,__zero_reg__
 607 01a4 00C0      		rjmp .L42
 608               	.LVL61:
 609               	.L47:
 381:usb.c         **** 			if (bmRequestType == 0x82) {
 610               		.loc 1 381 0
 611 01a6 80E0      		ldi r24,0
 612               	.LVL62:
 613               	.L42:
 386:usb.c         **** 			}
 387:usb.c         **** 			UEDATX = i;
 614               		.loc 1 387 0
 615 01a8 8093 F100 		sts 241,r24
 388:usb.c         **** 			UEDATX = 0;
 616               		.loc 1 388 0
 617 01ac 1092 F100 		sts 241,__zero_reg__
 618 01b0 00C0      		rjmp .L60
 619               	.LVL63:
 620               	.L36:
 389:usb.c         **** 			usb_send_in();
 390:usb.c         **** 			return;
 391:usb.c         **** 		}
 392:usb.c         **** 		if ((bRequest == CLEAR_FEATURE || bRequest == SET_FEATURE)
 621               		.loc 1 392 0
 622 01b2 282F      		mov r18,r24
 623               	.LVL64:
 624 01b4 2D7F      		andi r18,lo8(-3)
 625 01b6 2130      		cpi r18,lo8(1)
 626 01b8 01F4      		brne .L41
 393:usb.c         **** 		  && bmRequestType == 0x02 && wValue == 0) {
 627               		.loc 1 393 0
 628 01ba 9230      		cpi r25,lo8(2)
 629 01bc 01F4      		brne .L41
 630               		.loc 1 393 0 is_stmt 0 discriminator 1
 631 01be 012B      		or r16,r17
 632 01c0 01F0      		breq .+2
 633 01c2 00C0      		rjmp .L14
 394:usb.c         **** 			i = wIndex & 0x7F;
 634               		.loc 1 394 0 is_stmt 1
 635 01c4 2E2D      		mov r18,r14
 636 01c6 2F77      		andi r18,lo8(127)
 637               	.LVL65:
 395:usb.c         **** 			if (i >= 1 && i <= MAX_ENDPOINT) {
 638               		.loc 1 395 0
 639 01c8 9FEF      		ldi r25,lo8(-1)
 640               	.LVL66:
 641 01ca 920F      		add r25,r18
 642 01cc 9430      		cpi r25,lo8(4)
 643 01ce 00F0      		brlo .+2
 644 01d0 00C0      		rjmp .L14
 645               	.LBB73:
 646               	.LBB74:
 263:usb.c         **** }
 647               		.loc 1 263 0
 648 01d2 9EEF      		ldi r25,lo8(-2)
 649 01d4 9093 E800 		sts 232,r25
 650               	.LBE74:
 651               	.LBE73:
 396:usb.c         **** 				usb_send_in();
 397:usb.c         **** 				UENUM = i;
 652               		.loc 1 397 0
 653 01d8 2093 E900 		sts 233,r18
 398:usb.c         **** 				if (bRequest == SET_FEATURE) {
 654               		.loc 1 398 0
 655 01dc 8330      		cpi r24,lo8(3)
 656 01de 01F4      		brne .+2
 657 01e0 00C0      		rjmp .L14
 399:usb.c         **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);
 400:usb.c         **** 				} else {
 401:usb.c         **** 					UECONX = (1<<STALLRQC)|(1<<RSTDT)|(1<<EPEN);
 658               		.loc 1 401 0
 659 01e2 89E1      		ldi r24,lo8(25)
 660               	.LVL67:
 661 01e4 8093 EB00 		sts 235,r24
 402:usb.c         **** 					UERST = (1 << i);
 662               		.loc 1 402 0
 663 01e8 81E0      		ldi r24,lo8(1)
 664 01ea 90E0      		ldi r25,0
 665 01ec 022E      		mov r0,r18
 666 01ee 00C0      		rjmp 2f
 667               		1:
 668 01f0 880F      		lsl r24
 669               		2:
 670 01f2 0A94      		dec r0
 671 01f4 02F4      		brpl 1b
 672               	.LVL68:
 673               	.L59:
 674 01f6 8093 EA00 		sts 234,r24
 403:usb.c         **** 					UERST = 0;
 675               		.loc 1 403 0
 676 01fa 1092 EA00 		sts 234,__zero_reg__
 677 01fe 00C0      		rjmp .L13
 678               	.LVL69:
 679               	.L41:
 404:usb.c         **** 				}
 405:usb.c         **** 				return;
 406:usb.c         **** 			}
 407:usb.c         **** 		}
 408:usb.c         **** 		if (wIndex == 0) {
 680               		.loc 1 408 0
 681 0200 EF28      		or r14,r15
 682 0202 01F4      		brne .L14
 409:usb.c         **** 			if (bmRequestType == 0x21 && bRequest == HID_SET_REPORT) {
 683               		.loc 1 409 0
 684 0204 9132      		cpi r25,lo8(33)
 685 0206 01F4      		brne .L14
 686               		.loc 1 409 0 is_stmt 0 discriminator 1
 687 0208 8930      		cpi r24,lo8(9)
 688 020a 01F4      		brne .L14
 689               	.LVL70:
 690               	.L45:
 691               	.LBB75:
 692               	.LBB76:
 693               	.LBB77:
 267:usb.c         **** }
 694               		.loc 1 267 0 is_stmt 1
 695 020c 8091 E800 		lds r24,232
 696 0210 82FF      		sbrs r24,2
 697 0212 00C0      		rjmp .L45
 698               	.LBE77:
 699               	.LBE76:
 410:usb.c         **** 				uint8_t buf[6];
 411:usb.c         **** 				len = RX_SIZE;
 412:usb.c         **** 				do {
 413:usb.c         **** 					n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 414:usb.c         **** 					usb_wait_receive_out();
 415:usb.c         **** 					buf[0] = UEDATX;
 700               		.loc 1 415 0
 701 0214 5091 F100 		lds r21,241
 702               	.LVL71:
 416:usb.c         **** 					buf[1] = UEDATX;
 703               		.loc 1 416 0
 704 0218 4091 F100 		lds r20,241
 705               	.LVL72:
 417:usb.c         **** 					buf[2] = UEDATX;
 706               		.loc 1 417 0
 707 021c 3091 F100 		lds r19,241
 708               	.LVL73:
 418:usb.c         **** 					buf[3] = UEDATX;
 709               		.loc 1 418 0
 710 0220 2091 F100 		lds r18,241
 711               	.LVL74:
 419:usb.c         **** 					buf[4] = UEDATX;
 712               		.loc 1 419 0
 713 0224 9091 F100 		lds r25,241
 714               	.LVL75:
 420:usb.c         **** 					buf[5] = UEDATX;
 715               		.loc 1 420 0
 716 0228 8091 F100 		lds r24,241
 717               	.LVL76:
 421:usb.c         **** 					if (buf[0] == 'r' && buf[1] == 'e' && buf[2] == 'b'
 718               		.loc 1 421 0
 719 022c 5237      		cpi r21,lo8(114)
 720 022e 01F4      		brne .L46
 721               		.loc 1 421 0 is_stmt 0 discriminator 1
 722 0230 4536      		cpi r20,lo8(101)
 723 0232 01F4      		brne .L46
 724 0234 3236      		cpi r19,lo8(98)
 725 0236 01F4      		brne .L46
 422:usb.c         **** 					 && buf[3] == 'o' && buf[4] == 'o' && buf[5] == 't') {
 726               		.loc 1 422 0 is_stmt 1
 727 0238 2F36      		cpi r18,lo8(111)
 728 023a 01F4      		brne .L46
 729               		.loc 1 422 0 is_stmt 0 discriminator 1
 730 023c 9F36      		cpi r25,lo8(111)
 731 023e 01F4      		brne .L46
 732 0240 8437      		cpi r24,lo8(116)
 733 0242 01F4      		brne .L46
 423:usb.c         **** 						// When we get the "reboot" message,
 424:usb.c         **** 						// pulse all port B, C, & D pins low
 425:usb.c         **** 						PORTB = 0, PORTC = 0, PORTD = 0;
 734               		.loc 1 425 0 is_stmt 1
 735 0244 15B8      		out 0x5,__zero_reg__
 736 0246 18B8      		out 0x8,__zero_reg__
 737 0248 1BB8      		out 0xb,__zero_reg__
 426:usb.c         **** 						DDRB = 0xFF, DDRC = 0xFF, DDRD = 0xFF;
 738               		.loc 1 426 0
 739 024a 8FEF      		ldi r24,lo8(-1)
 740               	.LVL77:
 741 024c 84B9      		out 0x4,r24
 742 024e 87B9      		out 0x7,r24
 743 0250 8AB9      		out 0xa,r24
 744               	.LVL78:
 745               	.LBB78:
 746               	.LBB79:
 747               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 748               		.loc 2 245 0
 749 0252 F8E0      		ldi r31,lo8(8)
 750 0254 FA95      		1: dec r31
 751 0256 01F4      		brne 1b
 752 0258 0000      		nop
 753               	.LBE79:
 754               	.LBE78:
 427:usb.c         **** 						_delay_us(25);
 428:usb.c         **** 						DDRB = 0, DDRC = 0, DDRD = 0;
 755               		.loc 1 428 0
 756 025a 14B8      		out 0x4,__zero_reg__
 757 025c 17B8      		out 0x7,__zero_reg__
 758 025e 1AB8      		out 0xa,__zero_reg__
 429:usb.c         **** 						PORTB = 0xFF, PORTC = 0xFF, PORTD = 0xFF;
 759               		.loc 1 429 0
 760 0260 85B9      		out 0x5,r24
 761 0262 88B9      		out 0x8,r24
 762 0264 8BB9      		out 0xb,r24
 763               	.LVL79:
 764               	.L46:
 765               	.LBB80:
 766               	.LBB81:
 271:usb.c         **** }
 767               		.loc 1 271 0
 768 0266 8BEF      		ldi r24,lo8(-5)
 769 0268 8093 E800 		sts 232,r24
 770               	.LVL80:
 771               	.LBE81:
 772               	.LBE80:
 430:usb.c         **** 						//DDRD = 0x40;
 431:usb.c         **** 						//PORTD = 0x40;
 432:usb.c         **** 					}
 433:usb.c         **** 					// ignore incoming bytes
 434:usb.c         **** 					usb_ack_out();
 435:usb.c         **** 					len -= n;
 436:usb.c         **** 				} while (len);
 437:usb.c         **** 				usb_wait_in_ready();
 773               		.loc 1 437 0
 774 026c 0E94 0000 		call usb_wait_in_ready
 775               	.LVL81:
 776               	.L60:
 777               	.LBB82:
 778               	.LBB83:
 263:usb.c         **** }
 779               		.loc 1 263 0
 780 0270 8EEF      		ldi r24,lo8(-2)
 781 0272 8093 E800 		sts 232,r24
 782 0276 00C0      		rjmp .L13
 783               	.LVL82:
 784               	.L14:
 785               	.LBE83:
 786               	.LBE82:
 787               	.LBE75:
 438:usb.c         **** 				usb_send_in();
 439:usb.c         **** 				return;
 440:usb.c         **** 			}
 441:usb.c         **** 		}
 442:usb.c         **** 	}
 443:usb.c         **** 	UECONX = (1<<STALLRQ) | (1<<EPEN);	// stall
 788               		.loc 1 443 0
 789 0278 81E2      		ldi r24,lo8(33)
 790 027a 8093 EB00 		sts 235,r24
 791               	.L13:
 792               	/* epilogue start */
 444:usb.c         **** }
 793               		.loc 1 444 0
 794 027e 0F90      		pop __tmp_reg__
 795 0280 DF91      		pop r29
 796 0282 CF91      		pop r28
 797 0284 FF91      		pop r31
 798 0286 EF91      		pop r30
 799 0288 BF91      		pop r27
 800 028a AF91      		pop r26
 801 028c 9F91      		pop r25
 802 028e 8F91      		pop r24
 803 0290 7F91      		pop r23
 804 0292 6F91      		pop r22
 805 0294 5F91      		pop r21
 806 0296 4F91      		pop r20
 807 0298 3F91      		pop r19
 808 029a 2F91      		pop r18
 809 029c 1F91      		pop r17
 810 029e 0F91      		pop r16
 811 02a0 FF90      		pop r15
 812 02a2 EF90      		pop r14
 813 02a4 0F90      		pop r0
 814 02a6 0FBE      		out __SREG__,r0
 815 02a8 0F90      		pop r0
 816 02aa 1F90      		pop r1
 817 02ac 1895      		reti
 818               		.cfi_endproc
 819               	.LFE13:
 821               		.local	usb_configuration
 822               		.comm	usb_configuration,1,1
 823               		.section	.progmem.data,"a",@progbits
 826               	descriptor_list:
 827 0000 0001      		.word	256
 828 0002 0000      		.word	0
 829 0004 0000      		.word	device_descriptor
 830 0006 12        		.byte	18
 831 0007 0002      		.word	512
 832 0009 0000      		.word	0
 833 000b 0000      		.word	config1_descriptor
 834 000d 22        		.byte	34
 835 000e 0022      		.word	8704
 836 0010 0000      		.word	0
 837 0012 0000      		.word	rawhid_hid_report_desc
 838 0014 16        		.byte	22
 839 0015 0021      		.word	8448
 840 0017 0000      		.word	0
 841 0019 0000      		.word	config1_descriptor+18
 842 001b 09        		.byte	9
 843 001c 0003      		.word	768
 844 001e 0000      		.word	0
 845 0020 0000      		.word	string0
 846 0022 04        		.byte	4
 847 0023 0103      		.word	769
 848 0025 0904      		.word	1033
 849 0027 0000      		.word	string1
 850 0029 0A        		.byte	10
 851 002a 0203      		.word	770
 852 002c 0904      		.word	1033
 853 002e 0000      		.word	string2
 854 0030 12        		.byte	18
 857               	string2:
 858 0031 12        		.byte	18
 859 0032 03        		.byte	3
 860 0033 5200      		.string	"R"
 861 0035 6500      		.string	"e"
 862 0037 6200      		.string	"b"
 863 0039 6F00      		.string	"o"
 864 003b 6F00      		.string	"o"
 865 003d 7400      		.string	"t"
 866 003f 6F00      		.string	"o"
 867 0041 7200      		.string	"r"
 868 0043 00        		.string	""
 869 0044 00        		.string	""
 872               	string1:
 873 0045 0A        		.byte	10
 874 0046 03        		.byte	3
 875 0047 5000      		.string	"P"
 876 0049 4A00      		.string	"J"
 877 004b 5200      		.string	"R"
 878 004d 4300      		.string	"C"
 879 004f 00        		.string	""
 880 0050 00        		.string	""
 883               	string0:
 884 0051 04        		.byte	4
 885 0052 03        		.byte	3
 886 0053 0904      		.word	1033
 889               	config1_descriptor:
 890 0055 09        		.byte	9
 891 0056 02        		.byte	2
 892 0057 22        		.byte	34
 893 0058 00        		.byte	0
 894 0059 01        		.byte	1
 895 005a 01        		.byte	1
 896 005b 00        		.byte	0
 897 005c C0        		.byte	-64
 898 005d 32        		.byte	50
 899 005e 09        		.byte	9
 900 005f 04        		.byte	4
 901 0060 00        		.byte	0
 902 0061 00        		.byte	0
 903 0062 01        		.byte	1
 904 0063 03        		.byte	3
 905 0064 00        		.byte	0
 906 0065 00        		.byte	0
 907 0066 00        		.byte	0
 908 0067 09        		.byte	9
 909 0068 21        		.byte	33
 910 0069 11        		.byte	17
 911 006a 01        		.byte	1
 912 006b 00        		.byte	0
 913 006c 01        		.byte	1
 914 006d 22        		.byte	34
 915 006e 16        		.byte	22
 916 006f 00        		.byte	0
 917 0070 07        		.byte	7
 918 0071 05        		.byte	5
 919 0072 81        		.byte	-127
 920 0073 03        		.byte	3
 921 0074 08        		.byte	8
 922 0075 00        		.byte	0
 923 0076 80        		.byte	-128
 926               	rawhid_hid_report_desc:
 927 0077 06        		.byte	6
 928 0078 00        		.byte	0
 929 0079 FF        		.byte	-1
 930 007a 0A        		.byte	10
 931 007b 00        		.byte	0
 932 007c 01        		.byte	1
 933 007d A1        		.byte	-95
 934 007e 01        		.byte	1
 935 007f 75        		.byte	117
 936 0080 08        		.byte	8
 937 0081 15        		.byte	21
 938 0082 00        		.byte	0
 939 0083 26        		.byte	38
 940 0084 FF        		.byte	-1
 941 0085 00        		.byte	0
 942 0086 95        		.byte	-107
 943 0087 06        		.byte	6
 944 0088 09        		.byte	9
 945 0089 02        		.byte	2
 946 008a 91        		.byte	-111
 947 008b 02        		.byte	2
 948 008c C0        		.byte	-64
 951               	device_descriptor:
 952 008d 12        		.byte	18
 953 008e 01        		.byte	1
 954 008f 00        		.byte	0
 955 0090 02        		.byte	2
 956 0091 00        		.byte	0
 957 0092 00        		.byte	0
 958 0093 00        		.byte	0
 959 0094 20        		.byte	32
 960 0095 C0        		.byte	-64
 961 0096 16        		.byte	22
 962 0097 77        		.byte	119
 963 0098 04        		.byte	4
 964 0099 00        		.byte	0
 965 009a 01        		.byte	1
 966 009b 01        		.byte	1
 967 009c 02        		.byte	2
 968 009d 00        		.byte	0
 969 009e 01        		.byte	1
 972               	endpoint_config_table:
 973 009f 01        		.byte	1
 974 00a0 C1        		.byte	-63
 975 00a1 02        		.byte	2
 976 00a2 00        		.byte	0
 977 00a3 00        		.byte	0
 978 00a4 00        		.byte	0
 979               		.text
 980               	.Letext0:
 981               		.file 3 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 usb.c
     /tmp/cc6XMdls.s:2      *ABS*:0000003e __SP_H__
     /tmp/cc6XMdls.s:3      *ABS*:0000003d __SP_L__
     /tmp/cc6XMdls.s:4      *ABS*:0000003f __SREG__
     /tmp/cc6XMdls.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cc6XMdls.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cc6XMdls.s:12     .text.usb_wait_in_ready:00000000 usb_wait_in_ready
     /tmp/cc6XMdls.s:35     .text.usb_init:00000000 usb_init
                             .bss:00000000 usb_configuration
     /tmp/cc6XMdls.s:80     .text.__vector_10:00000000 __vector_10
     /tmp/cc6XMdls.s:142    .text.__vector_11:00000000 __vector_11
     /tmp/cc6XMdls.s:826    .progmem.data:00000000 descriptor_list
     /tmp/cc6XMdls.s:972    .progmem.data:0000009f endpoint_config_table
     /tmp/cc6XMdls.s:951    .progmem.data:0000008d device_descriptor
     /tmp/cc6XMdls.s:889    .progmem.data:00000055 config1_descriptor
     /tmp/cc6XMdls.s:926    .progmem.data:00000077 rawhid_hid_report_desc
     /tmp/cc6XMdls.s:883    .progmem.data:00000051 string0
     /tmp/cc6XMdls.s:872    .progmem.data:00000045 string1
     /tmp/cc6XMdls.s:857    .progmem.data:00000031 string2

UNDEFINED SYMBOLS
__do_clear_bss
